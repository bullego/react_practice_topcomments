
/*
Comments
--------
Task_1
Создать верстку под будущее приложение согласно макету




Task_2
Работа с сервером по получению и отрисовке постов и фильтрация постов.

Для получения данных будем использовать нативный метод fetch(), т.к. запрос на сервер будет один и по-этому подключать сторонние библиотеки (axios, jQuery) нет большого смысла.

Все сайд-эффекты, напр. запрос на сервер, должны происходить в методах ЖЦ componentDidMount либо componentDidUpdate.

Создаем локальный STATE и пустой исходный массив posts=[] для дальнейшего его наполнения инфой данными с сервака.

  App.js
  ------
  ...
  export class App extends React.Component {
    state = {
      posts: []
    }

    componentDidMount() {
      fetch('https://www.reddit.com/r/reactjs.json?limit=100')
    }
    
    render(){...}
  }

-----

Если сервер сообщает о CORS, можно попробовать решить проблему добавлением в запрос второго параметра в fetch('https://www.reddit.com/r/reactjs.json?limit=100', { mode: 'cors' }), либо добавлением в файл package.json строчки "proxy": "http://localhost:3000"

Про CORS:
https://create-react-app.dev/docs/proxying-api-requests-in-development/

-----

После добавления строчки fetch('https://www.reddit.com/r/reactjs.json?limit=100') во вкладке Network -> выбираем файл "reactjs.json?limit=100" -> вкладка Preview должна отобразится инфа с данными:

  {kind: "Listing", data: {modhash: "", dist: 102,…}}
  -data: {modhash: "", dist: 102,…}
    after: "t3_jnd7zo"
    before: null
    -children: [{kind: "t3", data: {approved_at_utc: null, subreddit: "reactjs",…}},…]
      [0 … 99]
      [100 … 101]
    dist: 102
    modhash: ""
  -kind: "Listing"

но она не отображается (хотя должна), для того чтоб отобразилась нужно вывести в консоль ответ с сервера через "then" и найти в св-ве "__proto__: Response" -> метод json():

  fetch('https://www.reddit.com/r/reactjs.json?limit=100').then(response => console.log(response))

->Response {type: "cors", url: "https://www.reddit.com/r/reactjs.json?limit=100", redirected: false, status: 200, ok: true, …}
  body: (...)
  bodyUsed: false
  ->headers: Headers {}
  ok: true
  redirected: false
  status: 200
  statusText: ""
  type: "cors"
  url: "https://www.reddit.com/r/reactjs.json?limit=100"
  ->__proto__: Response
    ...
    headers: (...)
    ->json: ƒ json()
    ok: (...)
    ...

Только после применения метода json() мы сможем видеть во вкладке Network -> Preview ответ с сервера.
Также, c помощью метода json() мы распарсим данные из data -> children, наши данные лежат именно там, и через еще один "then" выведем данные в консоль.
  fetch('https://www.reddit.com/r/reactjs.json?limit=100')
    .then(response => response.json())
    .then(data => console.log(data))

инфа в консоле:

{kind: "Listing", data: {…}}  
  -data:
    after: "t3_jnd7zo"
    before: null
    -children: Array(102)
      [0 … 99]
      [100 … 101]
      length: 102
      __proto__: Array(0)
    dist: 102
    modhash: ""
    __proto__: Object
  kind: "Listing"
  -__proto__: Object

-----

Если не писать цепочку промисов в сокращенном виде, нужно не забывать возвращать в следующий "then" результат предыдущего:

  fetch('https://www.reddit.com/r/reactjs.json?limit=100')
    .then(response => {
      return response.json();
    })
    .then(data => console.log(data))

-----

Дальше полученные данные с сервера нужно записать в STATE:

  fetch('https://www.reddit.com/r/reactjs.json?limit=100')
  .then(response => response.json())
  .then(data => {
    this.setState({
      posts: data.data.children
    })
  })

Теперь, если проверить вкладку DevTools -> Components (React-овская вкладка), и выбрать компоненту App, то мы увидим что в STATE -> posts записались входящие данные:

App
  state
    posts: [ {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, … ]

Чтоб не писать повторно data.data.children, можно сделать деструктуризацию {data}

  .then(({ data }) => {
    this.setState({
      posts: data.children
    })
  })

Список постов у нас лежит в теге <ul><li> пост_1 </li></ul>, соответственно этих постов должно быть столько, сколько данных(обьектов в данными) пришло с сервера, а их 102шт.(dist: 102)

Список будем отображать через декларативный метод массивов - map(). При отображении списка не забываем указывать ключ key + подставить нужные данные в соответствующие поля:

  App.js
  ------
  ...

  export class App extends React.Component {
    state = {
      posts: []
    }

    componentDidMount() {
      fetch('https://www.reddit.com/r/reactjs.json?limit=100')
      .then(response => response.json())
      .then(({ data }) => {
        this.setState({
          posts: data.children
        })
      })
    }

    render() {
      const {posts} = this.state;

      return (
        <div className={stl.app_wrap}>
          <h1 className={stl.app_title}>Top commented.</h1>
          
          <ul className={stl.gallery_items}>
            {
              posts.map(post => {
                return (
                  <li className={stl.gallery_item}
                      key={post.data.id}>
                    {
                      post.data.thumbnail && <img src={post.data.thumbnail} alt='gallery'/>
                    }
                    <h3>{post.data.title}</h3>
                    <p>Number of comments: {post.data.num_comments}</p>
                    <a href={`https://www.reddit.com${post.data.permalink}`}
                       target='_blank'
                       rel="noreferrer">
                      link
                    </a>
                  </li>
                )
              })
            }
          </ul>
        </div>
      )
    }
  }

Теперь мы получили 102 поста на странице.

Всегда, когда мы чтото загружаем, мы должны отображать прелоадер-крутилку либо аналог, на случай плохого соединения или доглгого ответа сервера.
И т.к. мы будем изменять состояние прелоадера (показать/спрятать, т.е. true/false), то нам нужно добавить это состояние в STATE:

  state = {
    posts: [],
    isLoading: false
  }

теперь при загрузке, которая стартует в componentDidMount, мы меняем флаг isLoading на true, а когда ответ пришел нужно прелоадер убрать isLoading: false. Добавляем логику появление/исчезания прелоадера:
 
  componentDidMount() {
    this.setState({
      isLoading: true
    })

    fetch('https://www.reddit.com/r/reactjs.json?limit=100')
    .then(response => response.json())
    .then(({ data }) => {
      this.setState({
        posts: data.children,
        isLoading: false
      })
    })
  }

добавим сам прелоадер в том месте, где отрисовуется список постов:

  render() {
    const {posts, isLoading} = this.state;

    return (
      <div className={stl.app_wrap}>
        <h1 className={stl.app_title}>Top commented.</h1>
        
        {isLoading 
          ? 
            <p>...Loading</p> 
          : 
          <ul className={stl.gallery_items}>
            { 
              posts.map(post => {
                return (
                  <li className={stl.gallery_item}
                      key={post.data.id}>
                    {
                      post.data.thumbnail && <img src={post.data.thumbnail} alt='gallery'/>
                    }
                    <h3>{post.data.title}</h3>
                    <p>Number of comments: {post.data.num_comments}</p>
                    <a href={`https://www.reddit.com${post.data.permalink}`}
                      target='_blank'
                      rel="noreferrer">
                      link
                    </a>
                  </li>
                )
              })
            }
          </ul>
        }
      </div>
    )
  }

Т.к. кода становится все больше, вынесем логику отрисовки поста в отдельную компоненту Post.jsx
    
  App.js
  ------
  import React from 'react';
  import stl from './App.module.css';
  import { Post } from './Post';

  export class App extends React.Component {
    state = {
      posts: [],
      isLoading: false
    }

    componentDidMount() {
      this.setState({
        isLoading: true
      })
      fetch('https://www.reddit.com/r/reactjs.json?limit=100')
      .then(response => response.json())
      .then(({ data }) => {
        this.setState({
          posts: data.children,
          isLoading: false
        })
      })
    }

    render() {
      const {posts, isLoading} = this.state;

      return (
        <div className={stl.app_wrap}>
          <h1 className={stl.app_title}>Top commented.</h1>
          
          {isLoading 
            ? 
              <p>...Loading</p> 
            : 
            <ul className={stl.gallery_items}>
              { posts.map(post => {
                  return (
                    <li key={post.data.id}
                        className={stl.gallery_item}>
                      <Post data={post.data} />
                    </li>
                  )
                })}
            </ul>
          }
        </div>
      )
    }
  }


  Post.jsx
  --------
  import React from 'react';
  import stl from './App.module.css';


  export class Post extends React.Component {
    render() {
      const { data } = this.props;

      return (
        <div className={stl.gallery_item_wrap}>
          {
            data.thumbnail && <img src={data.thumbnail} alt='gallery'/>
          }
          <h3>{data.title}</h3>
          <p>Number of comments: {data.num_comments}</p>
          <a href={`https://www.reddit.com${data.permalink}`}
            target='_blank'
            rel="noreferrer">
            link
          </a>
        </div>	
      )
    }
  }

Последним пунктом задания является сортировка постов по кол-ву комментариев. Для сортировки не нужно создавать отдельное состояние в STATE (не сильно ясно почему, возможно потому, что мы не будем использовать отображать не отсортированный полученный с сервера список). Для сортировки используем метод массивов sort():

Пример:
  let arr = [4, 1, 3, 5, 7];

  arr.sort((a,b) => a-b); |-> [1, 3, 4, 5, 7]
  arr.sort((a,b) => b-a); |-> [7, 5, 4, 3, 1]

  App.js
  ------
  ...

  export class App extends React.Component {
    state = {
      posts: [],
      isLoading: false
    }

    componentDidMount() {
      this.setState({
        isLoading: true
      })
      fetch('https://www.reddit.com/r/reactjs.json?limit=100')
      .then(response => response.json())
      .then(({ data }) => {
        this.setState({
          posts: data.children,
          isLoading: false
        })
      })
    }

    render() {
      const {posts, isLoading} = this.state;
      const sortPostsByComments = posts.sort((a,b) => b.data.num_comments - a.data.num_comments);

      return (
        <div className={stl.app_wrap}>
          <h1 className={stl.app_title}>Top commented.</h1>
          
          {isLoading 
            ? 
              <p>...Loading</p> 
            : 
            <ul className={stl.gallery_items}>
              { sortPostsByComments.map(post => {
                  return (
                    <li key={post.data.id}
                        className={stl.gallery_item}>
                      <Post data={post.data} />
                    </li>
                  )
                })}
            </ul>
          }
        </div>
      )
    }
  }

производим сортировку в методе render() и проходимся методом массива map() сразу по сортировке.



Task_3
Добавить кнопку "обновления данных" каждые 3сек. После нажатия на кноку она превращается в кнопку "Остановить обновление".

Добавляем кнопку для автообновления и создаем для нее событие onClick, которое запустит метод updateAutoRefresh. Для этого метода нужно повторить логику запроса на сервер за данными, по-этому вынесем эту логику в отдельную ф-ю getPosts(), т.к. она используется еще и в componentDidMount:

  App.js
  ------
  ...
  componentDidMount() {
    this.getPosts();
  }

  getPosts = () => {
    this.setState({
      isLoading: true
    })
    fetch('https://www.reddit.com/r/reactjs.json?limit=100')
    .then(response => response.json())
    .then(({ data }) => {
      this.setState({
        posts: data.children,
        isLoading: false
      })
    })
  }

  updateAutoRefresh = () => {
    setInterval(this.getPosts, 3000)
  }

  render() {
    ...
    return (
      <div className={stl.app_wrap}>
        ...
        
        <button onClick={this.updateAutoRefresh}
                type='button'
                className={stl.autorefresh_btn}>
          Start autorefresh
        </button>
        ...
      </div>
    )
  })}

теперь по нажатию на кнопку "Start autorefresh" каждые 3 сек будет уходить запрос на сервер за данными, которые будут отрисовываться в приложении.
Чтоб небыло зацикленности, рано или поздно нужно удалить setInterval, по-этому сначала создадим для запуска интервала переменную "this.refreshPosts" (? не понятно, почему работает только через this), чтобы потом через нее остановить (очистить) запущенный интервал. К тому же это нужно по условию задания. При повторном нажатии на кнопку обновление и отрисовка данных должна прекратиться.

Создаем доп. флаг в STATE - activeAutoRefreshBtn, который будет переключать кнопку запуска и остановки автообновления данных.


  App.js
  ------
  export class App extends React.Component {
    state = {
      posts: [],
      isLoading: false,
      activeAutoRefreshBtn: false
    }

    componentDidMount() {
      this.getPosts();
    }

    getPosts = () => {
      this.setState({
        isLoading: true
      })
      fetch('https://www.reddit.com/r/reactjs.json?limit=100')
      .then(response => response.json())
      .then(({ data }) => {
        this.setState({
          posts: data.children,
          isLoading: false
        })
      })
    }

    updateAutoRefresh = () => {
      if(this.state.activeAutoRefreshBtn) {
        this.setState({activeAutoRefreshBtn: false});
        clearInterval(this.refreshPosts);
      }
      else {
        this.setState({activeAutoRefreshBtn: true});
        this.refreshPosts = setInterval(this.getPosts, 3000);
      }
    }
    

    render() {
      const {posts, isLoading, activeAutoRefreshBtn} = this.state;
      const sortPostsByComments = posts.sort((a,b) => b.data.num_comments - a.data.num_comments);

      return (
        <div className={stl.app_wrap}>
          <h1 className={stl.app_title}>Top commented.</h1>
          
          <button onClick={this.updateAutoRefresh}
                  type='button'
                  className={stl.autorefresh_btn}>
            { activeAutoRefreshBtn ? 'Stop' : 'Start' } auto refresh
          </button>
          
          {isLoading 
            ? 
              <p>...Loading</p> 
            : 
            <ul className={stl.gallery_items}>
              { sortPostsByComments.map(post => {
                  return (
                    <li key={post.data.id}
                        className={stl.gallery_item}>
                      <Post data={post.data} />
                    </li>
                  )
                })}
            </ul>
          }
        </div>
      )
    }
  }

теперь по нажатию на кнопку "Start auto refresh", произойдет запуск обновления данных каждые 3 сек, после этого кнопка сменится на "Stop auto refresh" и по ее нажатию обновление данных прекратится.

Кнопку запуска/остановки можно не выносить в отдельную компоненту, т.к. код не очень большой и читаемость нормальная.



Task_4
Добавить бегунок диапазона который будет сортировать посты по кол-ву комментариев. Если комментариев для подходящего диапазона нет, показываем сообщение "No results found matching your criteria".
Напр. выбираем диапазон от 0 до 50 и получаем отсортированный список постов.

  |...............|---------------------------|
  0               50                         200

Используем input type='range' для создания слайдера-бегунка

  <input type='range'
         min={0}  //минимальное значение слайдера
         max={200} //макс.значение, выбираем с запасом относительно существующего мак.коментария
         step={5} //шаг слайдера
         defaultValue={0} //стартуем с 0
         className={stl.autorefresh_slide}/> 

нам понадобится новое значение в STATE - "minPostComments", которое будет отображать минимальное кол-во комментариев с которого мы будем начинать сортировку до выбранного максимального значения 200.
Добавляем в input событие onChange на изменение ползунка и присваиваем defaultValue то значение со STATE-а которое мы будем изменять через ползунок:
  
  setMinPostComments = (e) => {
    this.setState({
      minPostComments: Number(e.target.value) //e.target.value возвращает строку, по-этому
                                                сразу  перводим ее в число
    })
  }

  <input ...
         defaultValue={minPostComments}
         onChange={this.setMinPostComments}/>

Добавляем фильтрацию для постов, и вставляем ее до сортировки, чтоб не сортировать лишний раз то, что точно не войдет в выборку постов.

  const sortPostsByComments = posts
        .filter(post => post.data.num_comments >= minPostComments)
        .sort((a,b) => b.data.num_comments - a.data.num_comments)


  App.js
  ------
  ...

  export class App extends React.Component {
    state = {
      posts: [],
      isLoading: false,
      activeAutoRefreshBtn: false,
      minPostComments: 0
    }

    componentDidMount() {
      this.getPosts();
    }

    getPosts = () => {
      this.setState({
        isLoading: true
      })

      fetch('https://www.reddit.com/r/reactjs.json?limit=100')
      .then(response => response.json())
      .then(({ data }) => {
        this.setState({
          posts: data.children,
          isLoading: false
        })
      })
    }

    updateAutoRefresh = () => {
      if(this.state.activeAutoRefreshBtn) {
        this.setState({activeAutoRefreshBtn: false});
        clearInterval(this.refreshPosts);
      }
      else {
        this.setState({activeAutoRefreshBtn: true});
        this.refreshPosts = setInterval(this.getPosts, 3000);
      }
    }

    setMinPostComments = (e) => {
      this.setState({
        minPostComments: Number(e.target.value)
      })
    }
    

    render() {
      const {posts, isLoading, activeAutoRefreshBtn, minPostComments} = this.state;
      const sortPostsByComments = posts
        .sort((a,b) => b.data.num_comments - a.data.num_comments)
        .filter(post => post.data.num_comments >= minPostComments);

      return (
        <div className={stl.app_wrap}>
          <h1 className={stl.app_title}>Top commented.</h1>
          
          <button onClick={this.updateAutoRefresh}
                  type='button'
                  className={stl.autorefresh_btn}>
            { activeAutoRefreshBtn ? 'Stop' : 'Start' } auto refresh
          </button>

          <div className={stl.autorefresh_slide_wrap}>
            <input type='range'
                   min={0}
                   max={200}
                   step={5}
                   defaultValue={minPostComments}
                   onChange={this.setMinPostComments}
                   className={stl.autorefresh_slide}/> 
            <p>Current filter: {this.state.minPostComments}</p>
          </div>
          
          {isLoading 
            ? 
              <p>...Loading</p> 
            : 
            <ul className={stl.gallery_items}>
              { sortPostsByComments.map(post => {
                  return (
                    <li key={post.data.id}
                        className={stl.gallery_item}>
                      <Post data={post.data} />
                    </li>
                  )
                })}
            </ul>
          }
        </div>
      )
    }
  }

логику по получению отфильтрованных и отсортированных постов лучше вынести в отдельную ф-ю и сделать ее чистой, т.е. такой, чтоб она возвращала ожидаемый результат при конкретных входящих данных:

  App.js
  ------
  ...

  export class App extends React.Component {
    ...

    getPostsByComments = (posts, minPostComments) => {
      return posts.filter(post => post.data.num_comments >= minPostComments)
                  .sort((a,b) => b.data.num_comments - a.data.num_comments);
    }

    render() {
      const {posts, isLoading, activeAutoRefreshBtn, minPostComments} = this.state;
      const sortPostsByComments = this.getPostsByComments(posts, minPostComments);

      return(...)
    }
  }

и теперь, если мы выбираем диапазон, в который не попадает ни один пост, мы должны показать сообщение об этом:

  {isLoading 
    ? 
      <p>...Loading</p> 
    : 
    sortPostsByComments.length > 0
      ?
      <ul className={stl.gallery_items}>
        { sortPostsByComments.map(post => {
            return (
              <li key={post.data.id}
                  className={stl.gallery_item}>
                <Post data={post.data} />
              </li>
            )
          })}
      </ul>
      :
      <p>No results found matching your criteria</p>
  }

-----

Теперь можно провести небольшой рефакторинг кода, напр. сделать классовую компоненту <Post/> функциональной и оптимизировать кол-во отрисовок этой компоненты при управлении ползунком-слайдером:

  Post.jsx
  --------
  ...

  export const Post = ({data}) => {
    console.log('render');
    return (
      <div className={stl.gallery_item_wrap}>
        {
          data.thumbnail && <img src={data.thumbnail} alt='gallery'/>
        }
        <h3>{data.title}</h3>
        <p>Number of comments: {data.num_comments}</p>
        <a href={`https://www.reddit.com${data.permalink}`}
            target='_blank'
            rel="noreferrer">
          link
        </a>
      </div>	
    )
  }

отследим в консоли кол-во отрисовок компоненты <Post/>, добавив console.log. При первой загрузке мы видим в консоле 102 сообщения о рендере, т.к. подгрузилось 102 поста с сервера. Дальше, двигая ползунок слайдера вправо-влево, на каждое его перемещение происходит перерендер компоненты и это не эффективная работа приложения. Нам нужно ввести shouldComponentUpdate для оптимальной перерисовки, но т.к. это компонента не классовая, а функциональная, воспользуемся вместо shouldComponentUpdate методом React-а - memo, в который обернем нашу ф-ю компоненту:

  Post.jsx
  --------
  import React, {memo} from 'react';
  import stl from './App.module.css';

  export const Post = memo( ({data}) => {
    console.log('render');
    return (
      <div className={stl.gallery_item_wrap}>
        {
          data.thumbnail && <img src={data.thumbnail} alt='gallery'/>
        }
        <h3>{data.title}</h3>
        <p>Number of comments: {data.num_comments}</p>
        <a href={`https://www.reddit.com${data.permalink}`}
            target='_blank'
            rel="noreferrer">
          link
        </a>
      </div>	
    )
  } );

теперь, благодаря memo() имеем более эффективную перерисовку и на движение ползунка вправо мы не увидим ни одной новой перерисовки в консоли, кроме тех исходних 102. При возвращении ползунка влево, т.е. с 200 до 0 по мере появления постов на странице будем видеть постепенное увеличение кол-ва перерисовок с 0 до 102 в консоли.

Так же можно зарефакторить метод обновления постов:

  Было:

  updateAutoRefresh = () => {
    if(this.state.activeAutoRefreshBtn) {
      this.setState({activeAutoRefreshBtn: false});
      clearInterval(this.refreshPosts);
    }
    else {
      this.setState({activeAutoRefreshBtn: true});
      this.refreshPosts = setInterval(this.getPosts, 3000);
    }
  }

  Стало:

  updateAutoRefresh = () => {
    this.setState(
      (state) => ({activeAutoRefreshBtn: !state.activeAutoRefreshBtn}),
      () => {
        if(this.state.activeAutoRefreshBtn) {
          this.refreshPosts = setInterval(this.getPosts, 3000);
        } else {
          clearInterval(this.refreshPosts);
        }
      }
    )
  }

метод setState может принимать первым параметром не только обьект setState({...}), но и ф-ю. Функция в своих аргументах принимает текущий state, а также props(свойства) компонента, которые используются для вычислений следующего состояния setState((state, props)).
Также setState может принимать второй параметр - callback.
Вариант с передачей в setState ф-ии дает гарантию, что мы работаем с актуальным значением STATE-а и PROPS-ов, т.к. любое стороннее действие может повлиять на значения state и props и мы будем иметь на входе не те данные, которые ожидаем и хотим изменить.

Пример:
Увеличиваем счетчик по нажатию на кнопку.

  state = {count : 0};

  increaseCount () {
    this.setState({count : this.state.count + 1});
    this.setState({count : this.state.count + 1});
    this.setState({count : this.state.count + 1});
  }

  <button onClick={this.increaseCount}> Increase </button>
  <span> {this.state.count} </span>
  
  |-> click -> 1(1 а не 3), click -> 2(2 а не 6), click -> 3(3 а не 9)

React, оптимизируя свою работу, может на несколько вызовов setState( ) — лишь один раз обновить состояние приложения.
Каждый раз когда React сталкивается с множественными setState(), из каждого вызова он извлекает передаваемый объект и соединяет их между собой. В результате получается один единственный объект, с которым в итоге и произойдет вызов setState().
Но в Javascript правило слияния объектов гласит: если объекты имеют свойства с одинаковыми ключами(названиями), то значение ключа последнего передаваемого объекта выигрывает и перезаписывает все предыдущие. И тогда, если в объектах есть свойства с одинаковыми ключами — в итоговый объект запишется лишь значение последнего из них this.setState({count : this.state.count + 1}).

Отсюда вывод:
Так как props и state компонента могут быть обновлены асинхронно, вы не должны полагаться только лишь на их значения, чтобы вычислить следующее состояние приложения.

ПРАВИЛЬНО выполнять цепочки setState-ов нужно через функциональный setState:

  state = {count : 0};

  increaseCount () {
    this.setState((prevState, props) => ({
      count: prevState.count + 1
    }));
    this.setState((prevState, props) => ({
      count: prevState.count + 1
    }));
    this.setState((prevState, props) => ({
      count: prevState.count + 1
    }));
  }

  <button onClick={this.increaseCount}> Increase </button>
  <span> {this.state.count} </span>
  
  |-> click -> 3, click -> 6, click -> 9

React обнаруживает множественные вызовы функциональных setState(), вместо того чтобы объединить все эти вызовы в один он исполняет их ровно в том порядке в каком они были вызваны.
React начинает обновлять состояние приложения с каждым вызовом функционального setState(), и каждому следующему в очереди вызову он передает уже вычисленное от предыдущего.


Полная статья по setState:
https://medium.com/@WoTzap/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-setstate-%D1%8D%D1%82%D0%BE-%D0%B1%D1%83%D0%B4%D1%83%D1%89%D0%B5%D0%B5-react-d262be6a6c02

Второй параметр - callback-и, обычно используют если нужно сделать какую-то проверку с гарантированно правильно измененным значением до этого, либо сделать запрос на сервер на основе измененного состояния и т.д.
*/